# Swift

## Swift和Objective-C有什么区别？

- Swift是强类型（静态）语言，有类型推断，Objective-C弱类型（动态）语言
- Swift面向协议编程，Objective-C面向对象编程
- Swift注重值类型，Objective-C注重引用类型
- Swift支持泛型，Objective-C只支持轻量泛型（给集合添加泛型）
- Swift支持静态派发（效率高）、动态派发（函数表派发、消息派发）方式，Objective-C支持动态派发（消息派发）方式
- Swift支持函数式编程（高阶函数）
- Swift的协议不仅可以被类实现，也可以被Struct和Enum实现
- Swift有元组类型、支持运算符重载
- Swift支持命名空间
- Swift支持默认参数
- Swift比Objective-C代码更简洁

## 派发机制

### 静态派发(直接派发)

- final、static关键字的函数
- Struct、Enum
- 协议的Extensions、 Class的Extensions

### 函数表派发

- Class默认、协议声明函数

### 消息派发

- dynamic修饰的函数(包含Extension)

## Struct和Class的区别？

- Struct不支持继承，Class支持继承
- Struct是值类型，Class是引用类型
- Struct无法修改自身属性值，函数需要添加mutating关键字
- Struct不需要deinit方法，因为值类型不关系引用计数，Class需要deinit方法
- Struct初始化方法是基于属性的

## ?与??的区别

- ？用来声明可选值，如果变量未初始化则自动初始化nil；在操作可选值时，如果可选值时nil则不响应后续的操作；使用as?进行向下转型操作；
- ?? 用来判断左侧可选值非空（not nil）时返回左侧值可选值，左侧可选值为空（nil）则返回右侧的值。

## mutating的作用

- Swift中协议是可以被Struct和Enum实现的，mutating关键字是为了能在被修饰的函数中修改Struct或Enum的变量值，对Class完全透明。

## Set(集合类型)的使用场景

- Set存储值类型相同、无序、去重

## final关键词的用法

- final关键词的作用：它修饰的类、方法、变量是不能被继承或重写的，编译器会报错。另外，通过它可以显示的指定函数的派发机制。

### lazy关键词的用法

- lazy关键词的作用：指定延时加载（懒加载），懒加载存储属性只会在首次使用时才会计算初始值属性。懒加载属性必须声明（var）为变量，因为常量属性（let）初始化之前会有值。 lazy修饰的属性非线程安全的。

### 闭包是引用类型吗?

- 闭包是引用类型。如果一个闭包被分配给一个变量，这个变量复制给另一个变量，那么他们引用的是同一个闭包，他们的捕捉列表也会被复制。

### static和class的区别

- static可以修饰属性和方法
  - 所修饰的属性和方法不能够被重写。
  - static修饰的类方法和属性包含了final关键字的特性，重写会报错
- class修饰方法和计算属性
  - 我们同样可以使用class修饰方法和计算属性，但是不能够修饰存储属性
  - 类方法和计算属性是可以被重写的，可以使用class关键字也可以static

### closure与block的区别

- closure是匿名函数、block是一个结构体对象
- closure通过逃逸闭包来在内部修改变量，block 通过 __block 修饰符

### 闭包

- 闭包会强引用它捕获的所有变量，非逃逸闭包不会造成循环应用，并且非逃逸闭包它的上下文的内存可以保存在栈上而不是堆上

#### 逃逸闭包

- 在函数作用域以外被调用的闭包

#### 非逃逸闭包

- 在函数作用域以内被调用的闭包

### Swift为什么将String,Array,Dictionary设计成值类型？

- 值类型相比引用类型,最大的优势在于内存使用的高效.
- 值类型在栈上操作,引用类型在堆上操作.栈上的操作仅仅是单个指针的上下移动,而堆上的操作则牵涉到合并、移位、重新链接等.也就是说Swift这样设计,大幅减少了堆上的内存分配和回收的次数.同时写时复制又将值传递和复制的开销降到了最低.
- String,Array,Dictionary设计成值类型,也是为了线程安全考虑.通过Swift的let设置,使得这些数据达到了真正意义上的“不变”,它也从根本上解决了多线程中内存访问和操作顺序的问题.
- 设计成值类型还可以提升API的灵活度.

### 值类型的写时复制

- 只有当一个结构体发生了写入行为时才会有复制行为。
- 在结构体内部用一个引用类型来存储实际的数据，在不进行写入操作的普通传递过程中，都是将内部的reference的引用计数+1，在进行写入操作时，对内部的reference做一次copy操作用来存储新的数据，防止和之前的reference产生意外的数据共享。
- swift中提供该[isKnownUniquelyReferenced]函数，他能检查一个类的实例是不是唯一的引用，如果是，我们就不需要对结构体实例进行复制，如果不是，说明对象被不同的结构体共享，这时对它进行更改就需要进行复制。

### 值类型与引用类型

- 类是引用类型, 结构体为值类型
- 结构体不可以继承
- 值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝
- 引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝
- 值类型是在栈中处理，引用类型是在堆中处理，栈中只牵扯到一个指针的上下移动，堆中要牵扯到合并、移动、重新链接等情况，所以值类型比引用类型更高效

### 存储属性和计算属性

#### 存储属性

- 存储在特定类或结构体实例里的一个常量或变量。存储属性可以是变量存储属性（用关键字 var 定义），也可以是常量存储属性（用关键字 let 定义）。

#### 计算属性

- 除存储属性外，类、结构体和枚举可以定义计算属性。计算属性不直接存储值，而是提供一个getter和一个可选的setter，来间接获取和设置其他属性或变量的值。